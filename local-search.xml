<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NOI笔记-排序算法</title>
    <link href="/2019/05/26/NOI%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2019/05/26/NOI%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>本文将列举出NOI中常见的几种排序算法，希望对大家有帮助😝!</p><blockquote><p>本文中使用的定义来源于Wikipedia。<br />本文中使用的图片除最后一张来源于cnblogs之外，其他图片均来源于VisuAlgo。<br />本文中的C++代码除归并排序处引用自Wikipedia，其他的排序的代码均为本人所写。</p></blockquote><h1 id="调用algorithm进行排序"><a class="markdownIt-Anchor" href="#调用algorithm进行排序"></a> 🤣调用algorithm进行排序</h1><p>algorithm中的std::sort()函数可以方便地进行排序，如果题目没有特殊要求，可以直接调用此函数。</p><p>C++代码</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/* your code ... */</span>sort(arr, arr + arr_len);<span class="hljs-comment">/* your code ... */</span></code></pre><h1 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 🧼冒泡排序</h1><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢「浮」到数列的顶端。</p><p><img src="https://i.loli.net/2019/06/29/5d16d824c545187370.gif" srcset="/img/loading.gif" alt="冒泡排序.gif" /></p><p>C++代码</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)    {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)        {            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])            {                swap(arr[j], arr[j + <span class="hljs-number">1</span>]);            }        }    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>{    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cin</span> &gt;&gt; len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];    }    <span class="hljs-keyword">return</span> len;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">' '</span>;    }    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> arr[N], len;    len = input(arr);    bubble_sort(arr, len);    output(arr, len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h1 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 👆选择排序</h1><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><img src="https://i.loli.net/2019/06/29/5d16d85e0784844278.gif" srcset="/img/loading.gif" alt="选择排序.gif" /></p><p>C++代码</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)    {        <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++)        {            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[<span class="hljs-built_in">min</span>])            {                <span class="hljs-built_in">min</span> = j;            }        }        swap(arr[i], arr[<span class="hljs-built_in">min</span>]);    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>{    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cin</span> &gt;&gt; len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];    }    <span class="hljs-keyword">return</span> len;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">' '</span>;    }    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> arr[N], len;    len = input(arr);    selection_sort(arr, len);    output(arr, len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h1 id="️插入排序"><a class="markdownIt-Anchor" href="#️插入排序"></a> 🀄️插入排序</h1><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="https://i.loli.net/2019/06/29/5d16ddc9b821858475.gif" srcset="/img/loading.gif" alt="插入排序.gif" /></p><p>C++代码</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)    {        <span class="hljs-keyword">int</span> key = arr[i];        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> ((j &gt;= <span class="hljs-number">0</span>) &amp;&amp; (key &lt; arr[j]))        {            arr[j + <span class="hljs-number">1</span>] = arr[j];            j--;        }        arr[j + <span class="hljs-number">1</span>] = key;    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>{    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cin</span> &gt;&gt; len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];    }    <span class="hljs-keyword">return</span> len;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">' '</span>;    }    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> arr[N], len;    len = input(arr);    insertion_sort(arr, len);    output(arr, len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 📦桶排序</h1><p>桶排序（Bucket sort）或所谓的箱排序，是一个排序演算法，工作的原理是将阵列分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序演算法或是以递归方式继续使用桶排序进行排序）。</p><p><img src="https://i.loli.net/2019/07/06/5d20b1d191b6870108.gif" srcset="/img/loading.gif" alt="桶排序.gif" /></p><p>C++代码</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000</span>;<span class="hljs-keyword">int</span> bucket[N] = {};<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucket_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> bucket[], <span class="hljs-keyword">int</span> len)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {        bucket[arr[i]]++;    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>{    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cin</span> &gt;&gt; len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];    }    <span class="hljs-keyword">return</span> len;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bucket[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)    {        <span class="hljs-keyword">while</span> (bucket[i]) {            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">' '</span>;            bucket[i]--;        }    }    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> arr[N], bucket[N] = {}, len;    len = input(arr);    bucket_sort(arr, bucket, len);    output(bucket, len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 🏇快速排序</h1><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次比较。在最坏状况下则需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>次比较，但这种状况并不常见。事实上，快速排序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>通常明显比其他演算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p><p><img src="https://i.loli.net/2019/07/13/5d29dac480e0296026.gif" srcset="/img/loading.gif" alt="快速排序.gif" /></p><p>C++代码</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> tail)</span></span>{    <span class="hljs-keyword">if</span> (head &gt;= tail)    {        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">int</span> i = head, j = tail;    <span class="hljs-keyword">int</span> pivot = arr[head];  <span class="hljs-comment">// 通常取第一个数为基准</span>    <span class="hljs-keyword">while</span> (i &lt; j) <span class="hljs-comment">// i,j 相遇即退出循环</span>    {        <span class="hljs-keyword">while</span> (i &lt; j <span class="hljs-keyword">and</span> arr[j] &gt;= pivot) <span class="hljs-comment">// 从右向左扫描，将比基准小的数填到左边</span>        {            j--;        }        arr[i] = arr[j];        <span class="hljs-keyword">while</span> (i &lt; j <span class="hljs-keyword">and</span> arr[i] &lt;= pivot) <span class="hljs-comment">// 从左向右扫描，将比基准大的数填到右边</span>        {            i++;        }        arr[j] = arr[i];    }    arr[i] = pivot; <span class="hljs-comment">// 将基准数填回</span>    quick_sort(arr, head, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 以基准数为界左右分治</span>    quick_sort(arr, j + <span class="hljs-number">1</span>, tail);}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>{    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cin</span> &gt;&gt; len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];    }    <span class="hljs-keyword">return</span> len;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">' '</span>;    }    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> arr[N], len;    len = input(arr);    quick_sort(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    output(arr, len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h1 id="归并排序二路"><a class="markdownIt-Anchor" href="#归并排序二路"></a> 🎛归并排序(二路)</h1><p>归并排序（英语：Merge sort，或mergesort），是建立在归并操作上的一种有效的排序算法，效率為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><p><img src="https://i.loli.net/2019/07/24/5d387662c1f1f47165.png" srcset="/img/loading.gif" alt="归并排序.png" /></p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;Array, <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>{    <span class="hljs-comment">// preconditions:</span>    <span class="hljs-comment">// Array[front...mid] is sorted</span>    <span class="hljs-comment">// Array[mid+1 ... end] is sorted</span>    <span class="hljs-comment">// Copy Array[front ... mid] to LeftSubArray</span>    <span class="hljs-comment">// Copy Array[mid+1 ... end] to RightSubArray</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">LeftSubArray</span><span class="hljs-params">(Array.<span class="hljs-built_in">begin</span>() + front, Array.<span class="hljs-built_in">begin</span>() + mid + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">RightSubArray</span><span class="hljs-params">(Array.<span class="hljs-built_in">begin</span>() + mid + <span class="hljs-number">1</span>, Array.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">end</span> + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">int</span> idxLeft = <span class="hljs-number">0</span>, idxRight = <span class="hljs-number">0</span>;    LeftSubArray.insert(LeftSubArray.<span class="hljs-built_in">end</span>(), numeric_limits&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">max</span>());    RightSubArray.insert(RightSubArray.<span class="hljs-built_in">end</span>(), numeric_limits&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">max</span>());    <span class="hljs-comment">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = front; i &lt;= <span class="hljs-built_in">end</span>; i++) {        <span class="hljs-keyword">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) {            Array[i] = LeftSubArray[idxLeft];            idxLeft++;        } <span class="hljs-keyword">else</span> {            Array[i] = RightSubArray[idxRight];            idxRight++;        }    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;Array, <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>{    <span class="hljs-keyword">if</span> (front &gt;= <span class="hljs-built_in">end</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = front + (<span class="hljs-built_in">end</span> - front) / <span class="hljs-number">2</span>;    MergeSort(Array, front, mid);    MergeSort(Array, mid + <span class="hljs-number">1</span>, <span class="hljs-built_in">end</span>);    Merge(Array, front, mid, <span class="hljs-built_in">end</span>);}</code></pre><h1 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h1><table><thead><tr><th>名称</th><th>平均时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>✔︎</td></tr><tr><td>选择排序</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>✖︎</td></tr><tr><td>插入排序</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td>✔︎</td></tr><tr><td>桶排序</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td>✖︎</td></tr><tr><td>快速排序</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td>✖︎</td></tr><tr><td>归并排序(二路)</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td>✔︎</td></tr></tbody></table><h1 id="选择"><a class="markdownIt-Anchor" href="#选择"></a> 选择</h1><p><img src="https://i.loli.net/2019/06/28/5d16281e44f2b75052.png" srcset="/img/loading.gif" alt="场景选择.png" /></p>]]></content>
    
    
    <categories>
      
      <category>NOI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NOI</tag>
      
      <tag>排序</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
